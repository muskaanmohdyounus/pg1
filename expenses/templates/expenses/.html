from django.db.models import Sum
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib.auth import authenticate, login, logout
from django.db.models.functions import TruncMonth
from django.http import JsonResponse
import random
from .models import Expense, OTP, ManagerProfile
from django.contrib import messages
from django.contrib.auth.models import User
from .models import ManagerOnboarding
from .models import Rent




def is_admin(user):
    """Check if the user is an authenticated admin (staff)."""
    return user.is_authenticated and user.is_staff




def index(request):
    """Homepage — ALWAYS show index. No redirects."""
    return render(request, 'expenses/index.html')


def login_view(request):
    """Handle login authentication."""
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)

        if user:
            login(request, user)
            return redirect('expense_list')
        else:
            return render(request, 'expenses/login.html', {
                'error': 'Invalid username or password.'
            })
    return render(request, 'expenses/login.html')


@login_required
def logout_view(request):
    """Logout and redirect to homepage."""
    logout(request)
    return redirect('index')


def signup(request):
    if request.method == "POST":

        full_name = request.POST.get("full_name")
        username = request.POST.get("username")
        email = request.POST.get("email")
        phone = request.POST.get("phone")
        pg_property = request.POST.get("pg_property")
        password = request.POST.get("password")
        confirm_password = request.POST.get("confirm_password")
        otp_entered = request.POST.get("otp")

        otp_record = OTP.objects.filter(phone=phone).order_by("-created_at").first()

        print("OTP ENTERED:", otp_entered)
        print("OTP RECORD:", otp_record)
        print("PASSWORDS:", password, confirm_password)
        print("USERNAME EXISTS:", User.objects.filter(username=username).exists())
        print("EMAIL EXISTS:", User.objects.filter(email=email).exists())

        if not otp_record or otp_record.otp_code != otp_entered:
            messages.error(request, "Invalid OTP. Please try again.")
            return render(request, "expenses/signup.html")

        if password != confirm_password:
            messages.error(request, "Passwords do not match.")
            return render(request, "expenses/signup.html")

        if User.objects.filter(username=username).exists():
            messages.error(request, "Username already exists.")
            return render(request, "expenses/signup.html")

        if User.objects.filter(email=email).exists():
            messages.error(request, "Email already registered.")
            return render(request, "expenses/signup.html")

       
        user = User.objects.create_user(
            username=username,
            email=email,
            password=password
        )

       
        ManagerProfile.objects.create(
            user=user,
            full_name=full_name,
            phone=phone,
            pg_property=pg_property
        )

        from django.contrib.auth import login
        login(request, user)

       
        return redirect("onboarding")

    return render(request, "expenses/signup.html")



def onboarding_view(request):
    onboarding, created = ManagerOnboarding.objects.get_or_create(user=request.user)

   
    questions = [
        "How many PG properties do you manage?",
        "How many total rooms are there?",
        "How many tenants are currently staying?",
        "Do you have staff? (Yes/No)",
        "What is your biggest challenge in managing the PG?"
    ]

    
    answers = [
        onboarding.answer1 or "",
        onboarding.answer2 or "",
        onboarding.answer3 or "",
        onboarding.answer4 or "",
        onboarding.answer5 or "",
    ]

    
    try:
        step = answers.index("")
    except ValueError:
       
        logout(request)
        return redirect('login')

   
    if request.method == "POST":
        ans = request.POST.get('answer')

        if step == 0:
            onboarding.answer1 = ans
        elif step == 1:
            onboarding.answer2 = ans
        elif step == 2:
            onboarding.answer3 = ans
        elif step == 3:
            onboarding.answer4 = ans
        elif step == 4:
            onboarding.answer5 = ans

        onboarding.save()

        return redirect('onboarding') 

    
    context = {
        'question': questions[step],
        'step': step + 1,
    }

    return render(request, 'expenses/onboarding.html', context)



from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.db.models import Sum
from .models import Expense

from .models import Property

@login_required
def expense_list(request):
    query = request.GET.get('q', '')
    start_date = request.GET.get('start_date', '')
    end_date = request.GET.get('end_date', '')

    expenses = Expense.objects.all().order_by('-entry_date')

    if query:
        expenses = expenses.filter(category__name__icontains=query)
    if start_date:
        expenses = expenses.filter(entry_date__gte=start_date)
    if end_date:
        expenses = expenses.filter(entry_date__lte=end_date)

    total = expenses.aggregate(Sum('amount'))['amount__sum'] or 0

    # Summary by category
    summary_categories = ['Utility', 'Food', 'Staff', 'Miscellaneous']
    category_summary = {}
    for cat_name in summary_categories:
        amt = expenses.filter(category__name__icontains=cat_name).aggregate(Sum('amount'))['amount__sum'] or 0
        category_summary[cat_name] = amt

    # Highest single expense
    highest_expense = expenses.order_by('-amount').first()

    # Category chart data
    category_totals = expenses.values('category__name').annotate(total_amount=Sum('amount')).order_by('-total_amount')
    chart_labels = [item['category__name'] or 'Uncategorized' for item in category_totals]
    chart_values = [item['total_amount'] for item in category_totals]

    # ✅ Fetch all properties for filter dropdown
    properties = Property.objects.all()

    return render(request, 'expenses/expense_list.html', {
        'expenses': expenses,
        'total': total,
        'category_summary': category_summary,
        'highest_expense': highest_expense,
        'chart_labels': chart_labels,
        'chart_values': chart_values,
        'properties': properties,  # <--- added
    })

@login_required
def expense_detail(request, id):
    expense = get_object_or_404(Expense, id=id)
    return render(request, 'expenses/expense_detail.html', {
        'expense': expense
    })


from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import user_passes_test
from .models import Expense, Category, Property

# Use a lambda directly instead of missing is_admin
@user_passes_test(lambda u: u.is_staff, login_url='index')
def add_expense(request):
    categories = Category.objects.all()
    properties = Property.objects.all()

    if request.method == "POST":
        property_id = request.POST.get("property")
        category_name = request.POST.get("category", "").strip()  # manual input
        sub_category = request.POST.get("sub_category", "").strip()
        amount = request.POST.get("amount")
        entry_date = request.POST.get("entry_date")
        description = request.POST.get("description", "").strip()
        bill_image = request.FILES.get("bill_image")

        # Validate required fields
        if not property_id or not amount or not entry_date:
            messages.error(request, "Please fill all required fields.")
            return redirect("expenses:add")

        # Get Property object safely
        try:
            prop = Property.objects.get(id=property_id)
        except Property.DoesNotExist:
            messages.error(request, "Invalid Property selected.")
            return redirect("expenses:add")

        # Get or create Category by name (manual input)
        cat = None
        if category_name:
            cat, created = Category.objects.get_or_create(name=category_name)

        # Create Expense
        Expense.objects.create(
            property=prop,
            category=cat,
            sub_category=sub_category,
            amount=amount,
            entry_date=entry_date,
            description=description,
            bill_image=bill_image
        )

        messages.success(request, "Expense added successfully!")
        return redirect("expense_list")


    context = {
        "categories": categories,
        "properties": properties
    }
    return render(request, "expenses/add_expense.html", context)



from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from .models import Expense, Property, Category

@login_required
def edit_expense(request, id):
    """Edit an existing expense record."""
    expense = get_object_or_404(Expense, id=id)
    
    categories = Category.objects.all()
    properties = Property.objects.all()

    if request.method == 'POST':
        # Basic fields
        expense.amount = request.POST.get('amount')
        expense.description = request.POST.get('description')
        expense.entry_date = request.POST.get('entry_date')
        expense.sub_category = request.POST.get('sub_category', '')

        # ForeignKeys
        category_id = request.POST.get('category')
        if category_id:
            expense.category = Category.objects.get(id=category_id)
        else:
            expense.category = None

        property_id = request.POST.get('property')
        if property_id:
            expense.property = Property.objects.get(id=property_id)
        else:
            expense.property = None

        # Optional fields
        expense.paid_by = request.POST.get('paid_by', '')
        expense.paid_to = request.POST.get('paid_to', '')
        paid_mode = request.POST.get('paid_mode')
        if paid_mode in dict(Expense.PAYMENT_MODES).keys():
            expense.paid_mode = paid_mode
        else:
            expense.paid_mode = 'Cash'  # default fallback

        # Bill image (only update if new file uploaded)
        if request.FILES.get('bill_image'):
            expense.bill_image = request.FILES.get('bill_image')

        expense.save()
        messages.success(request, "Expense updated successfully!")
        return redirect('expense_list')

    return render(request, 'expenses/edit_expense.html', {
        'expense': expense,
        'categories': categories,
        'properties': properties,
    })




@user_passes_test(is_admin, login_url='index')
def delete_expense(request, id):
    """Delete an expense record."""
    expense = get_object_or_404(Expense, id=id)
    expense.delete()
    return redirect('expense_list')

@user_passes_test(is_admin, login_url='index')
def settings_page(request):
    """Display Settings page."""
    return render(request, 'expenses/settings.html')

def reports_page(request):
    
    monthly_data = (
        Expense.objects
        .annotate(month=TruncMonth('date'))
        .values('month')
        .annotate(total=Sum('amount'))
        .order_by('-month')
    )

   
    monthly_reports = []
    for data in monthly_data:
        month = data['month']
        total = data['total']
        top_category = (
            Expense.objects.filter(date__month=month.month)
            .values('category')
            .annotate(total_category=Sum('amount'))
            .order_by('-total_category')
            .first()
        )
        monthly_reports.append({
            'month': month.strftime('%B %Y'),
            'total': total,
            'top_category': top_category['category'] if top_category else 'N/A',
            'top_category_total': top_category['total_category'] if top_category else 0
        })

    return render(request, 'expenses/reports.html', {'monthly_reports': monthly_reports})

def send_otp(request):
    phone = request.GET.get("phone")

    if not phone:
        return JsonResponse({"status": "error", "message": "Phone number required"})

    otp_code = str(random.randint(1000, 9999))

    
    OTP.objects.create(phone=phone, otp_code=otp_code)

    
    print("===================================")
    print(f"OTP for {phone} → {otp_code}")
    print("===================================")

    return JsonResponse({"status": "success", "message": "OTP sent"})



from django.shortcuts import render, get_object_or_404, redirect
from django.urls import reverse
from .models import Property
from .forms import PropertyForm
from .models import PropertyImage



# ✅ 1. PROPERTY LIST — shows all properties
def property_list(request):
    properties = Property.objects.all().order_by('-id')
    return render(request, 'expenses/property_list.html', {
        'properties': properties
    })


# ✅ 2. ADD NEW PROPERTY
def add_property(request):
    if request.method == 'POST':
        form = PropertyForm(request.POST)
        files = request.FILES.getlist('images')

        if form.is_valid():
            property_obj = form.save()

            # Save uploaded images
            for file in files:
                PropertyImage.objects.create(property=property_obj, image=file)

            return redirect('property_list')
    else:
        form = PropertyForm()

    return render(request, 'expenses/add_property.html', {
        'form': form
    })



# ✅ 3. PROPERTY DETAIL PAGE
def property_detail(request, id):
    property_obj = get_object_or_404(Property, id=id)
    return render(request, 'expenses/property_detail.html', {
        'property': property_obj
    })


# ✅ 4. EDIT PROPERTY
def edit_property(request, id):
    property_obj = get_object_or_404(Property, id=id)

    if request.method == 'POST':
        form = PropertyForm(request.POST, instance=property_obj)
        files = request.FILES.getlist('images')

        if form.is_valid():
            form.save()

            # Add new images
            for file in files:
                PropertyImage.objects.create(property=property_obj, image=file)

            return redirect('property_detail', id=id)

    else:
        form = PropertyForm(instance=property_obj)

    return render(request, 'expenses/edit_property.html', {
        'form': form,
        'property': property_obj,
        'images': property_obj.images.all()
    })



# ✅ 5. DELETE PROPERTY
def delete_property(request, id):
    property_obj = get_object_or_404(Property, id=id)

    if request.method == 'POST':
        property_obj.delete()
        return redirect('property_list')

    return render(request, 'expenses/delete_confirm.html', {
        'property': property_obj
    })

import json
from collections import Counter
from django.shortcuts import render
from .models import Property

def property_graph(request):
    properties = Property.objects.all()

    # Chart 1: Occupancy per property
    property_names = [p.name for p in properties]
    occupancy = [p.occupancy_percent for p in properties]

    # Chart 2: Property type distribution
    types = [p.type for p in properties]
    type_counts = dict(Counter(types))

    # Chart 3: Occupied vs Vacant beds
    occupied_beds = [p.occupied_beds for p in properties]
    vacant_beds = [p.vacant_beds for p in properties]

    context = {
        'property_names': json.dumps(property_names),
        'occupancy': json.dumps(occupancy),
        'type_labels': json.dumps(list(type_counts.keys())),
        'type_counts': json.dumps(list(type_counts.values())),
        'occupied_beds': json.dumps(occupied_beds),
        'vacant_beds': json.dumps(vacant_beds),
    }

    return render(request, 'expenses/property_graph.html', context)
 

from django.shortcuts import render, redirect
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.db.models import Sum
from .models import Rent, Loan
from .forms import LoanForm

# ============================================================
# TENANT RENT VIEWS
# ============================================================

def tenant_rent(request):
    """
    Show all rents and handle rent submission
    """
    if request.method == "POST":
        Rent.objects.create(
            tenant_name=request.POST.get("tenant_name"),
            room_number=request.POST.get("room_number"),
            billing_month=request.POST.get("billing_month"),
            billing_year=request.POST.get("billing_year"),
            billing_date=request.POST.get("billing_date"),
            rent_cycle=request.POST.get("rent_cycle"),
            rent_amount=request.POST.get("rent_amount"),
            payment_method=request.POST.get("payment_method"),
            utr_number=request.POST.get("utr_number"),
            bill_upload=request.FILES.get("bill_upload"),
            notes=request.POST.get("notes"),
        )
        messages.success(request, "Rent added successfully.")
        return redirect("tenant_rent")

    rents = Rent.objects.all().order_by("-created_at")
    return render(request, "expenses/tenant/tenant_rent.html", {"rents": rents})

from django.shortcuts import render, redirect
from .models import Rent

def add_rent(request):
    if request.method == "POST":
        Rent.objects.create(
            tenant_name=request.POST.get("tenant_name"),
            room_number=request.POST.get("room_number"),
            billing_month=request.POST.get("billing_month"),
            billing_year=request.POST.get("billing_year"),
            billing_date=request.POST.get("billing_date"),
            rent_cycle=request.POST.get("rent_cycle"),
            rent_amount=request.POST.get("rent_amount"),
            payment_method=request.POST.get("payment_method"),
            utr_number=request.POST.get("utr_number"),
            bill_upload=request.FILES.get("bill_upload"),
            notes=request.POST.get("notes"),
        )
        return redirect("tenant_rent")

    return render(request, "expenses/tenant/add_rent.html")

def edit_rent(request, id):
    rent = get_object_or_404(Rent, id=id)

    if request.method == "POST":
        rent.tenant_name = request.POST.get("tenant_name")
        rent.room_number = request.POST.get("room_number")
        rent.billing_month = request.POST.get("billing_month")
        rent.billing_year = request.POST.get("billing_year")
        rent.rent_amount = request.POST.get("rent_amount")
        rent.payment_method = request.POST.get("payment_method")
        rent.notes = request.POST.get("notes")
        rent.save()
        messages.success(request, "Rent updated successfully.")
        return redirect("tenant_rent")

    return render(request, "expenses/tenant/edit_rent.html", {"rent": rent})


def delete_rent(request, id):
    rent = get_object_or_404(Rent, id=id)
    rent.delete()
    messages.success(request, "Rent deleted successfully.")
    return redirect("tenant_rent")


# ============================================================
# HELPER: Read tenant info from session
# ============================================================

def get_current_tenant(request):
    tenant_id = request.session.get("tenant_id")
    tenant_name = request.session.get("tenant_name")
    room_number = request.session.get("room_number")

    if not tenant_id or not tenant_name:
        return None

    return {
        "tenant_id": tenant_id,
        "tenant_name": tenant_name,
        "room_number": room_number,
    }

# ============================================================
# TENANT LOAN VIEWS
# ============================================================

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.db.models import Sum
from .models import Loan, Tenant
from .forms import LoanForm
from functools import wraps

# ================================
# DECORATOR TO CHECK TENANT LOGIN
# ================================
def tenant_required(view_func):
    @wraps(view_func)
    def wrapper(request, *args, **kwargs):
        if not request.session.get("tenant_id"):
            messages.warning(request, "Please login as a tenant first.")
            return redirect('tenant_login')  # tenant login page
        return view_func(request, *args, **kwargs)
    return wrapper

# ================================
# HELPER TO GET CURRENT TENANT
# ================================
def get_current_tenant(request):
    tenant_id = request.session.get("tenant_id")
    tenant_name = request.session.get("tenant_name")
    room_number = request.session.get("room_number")

    if not tenant_id or not tenant_name:
        return None

    return {
        "tenant_id": tenant_id,
        "tenant_name": tenant_name,
        "room_number": room_number,
    }

# ================================
# TENANT LOGIN
# ================================
def tenant_login(request):
    if request.method == "POST":
        email = request.POST.get('email')
        password = request.POST.get('password')

        tenant = Tenant.objects.filter(tenant_email=email, password=password).first()
        if tenant:
            # Store tenant info in session
            request.session['tenant_id'] = tenant.id
            request.session['tenant_name'] = tenant.tenant_name
            request.session['room_number'] = tenant.room_number

            messages.success(request, f"Welcome, {tenant.tenant_name}!")
            return redirect('tenant_loan_list')  # redirect to tenant loans page
        else:
            messages.error(request, "Invalid email or password.")
            return redirect('tenant_login')

    return render(request, 'expenses/tenant/tenant_login.html')


# ================================
# TENANT LOAN LIST
# ================================
@tenant_required
def tenant_loan_list(request):
    tenant = get_current_tenant(request)
    loans = Loan.objects.filter(tenant_id=tenant["tenant_id"]) if tenant else Loan.objects.none()

    total_taken = loans.aggregate(total=Sum("approved_amount"))["total"] or 0
    total_pending = loans.filter(status="pending").aggregate(total=Sum("loan_amount_requested"))["total"] or 0
    emi_this_month = loans.filter(status__in=["approved", "disbursed"]).aggregate(total=Sum("monthly_installment"))["total"] or 0
    last_loan = loans.first() if loans.exists() else None

    return render(request, "expenses/tenant/tenantloan.html", {
        "loans": loans,
        "tenant": tenant,
        "total_taken": total_taken,
        "total_pending": total_pending,
        "emi_this_month": emi_this_month,
        "last_loan": last_loan,
    })


# ================================
# TENANT APPLY LOAN
# ================================
@tenant_required
def tenant_apply_loan(request):
    tenant = get_current_tenant(request)

    if request.method == "POST":
        form = LoanForm(request.POST, request.FILES)
        if form.is_valid():
            loan = form.save(commit=False)

            if tenant:
                loan.tenant_name = tenant["tenant_name"]
                loan.tenant_id = tenant["tenant_id"]
                loan.room_number = tenant["room_number"]

            loan.status = "pending"
            loan.save()
            messages.success(request, "Loan application submitted successfully.")
            return redirect("tenant_loan_list")
    else:
        form = LoanForm()

    return render(request, "expenses/tenant/loan_apply.html", {"form": form})


# ================================
# TENANT EDIT LOAN
# ================================
@tenant_required
def tenant_edit_loan(request, pk):
    tenant = get_current_tenant(request)
    loan = get_object_or_404(Loan, pk=pk, tenant_id=tenant["tenant_id"])

    if loan.status != "pending":
        messages.error(request, "Only pending loans can be edited.")
        return redirect("tenant_loan_list")

    if request.method == "POST":
        form = LoanForm(request.POST, request.FILES, instance=loan)
        if form.is_valid():
            form.save()
            messages.success(request, "Loan updated successfully.")
            return redirect("tenant_loan_list")
    else:
        form = LoanForm(instance=loan)

    return render(request, "expenses/tenant/loan_edit.html", {"form": form, "loan": loan})


# ================================
# TENANT DELETE LOAN
# ================================
@tenant_required
def tenant_delete_loan(request, pk):
    tenant = get_current_tenant(request)
    loan = get_object_or_404(Loan, pk=pk, tenant_id=tenant["tenant_id"])

    if loan.status != "pending":
        messages.error(request, "Only pending loans can be deleted.")
        return redirect("tenant_loan_list")

    loan.delete()
    messages.success(request, "Loan deleted successfully.")
    return redirect("tenant_loan_list")


# ================================
# SELECT LOGIN TYPE
# ================================
def select_login_type(request):
    return render(request, 'expenses/select_login_type.html')




# ========================================
# OWNER LOAN LIST
# ========================================
def owner_loan_list(request):
    loans = Loan.objects.all().order_by("-id")

    # Categorize loans
    pending_loans = loans.filter(status="pending")
    approved_loans = loans.filter(status="approved")
    rejected_loans = loans.filter(status="rejected")

    # Summary cards
    total_requested = loans.aggregate(total=Sum("loan_amount_requested"))["total"] or 0
    total_approved = approved_loans.aggregate(total=Sum("approved_amount"))["total"] or 0
    total_rejected = rejected_loans.count()
    total_pending = pending_loans.count()

    return render(request, "expenses/owner_loan_list.html", {
        "pending_loans": pending_loans,
        "approved_loans": approved_loans,
        "rejected_loans": rejected_loans,
        "total_requested": total_requested,
        "total_approved": total_approved,
        "total_rejected": total_rejected,
        "total_pending": total_pending,
    })

# ========================================
# APPROVE LOAN
# ========================================
def approve_loan(request):
    if request.method == "POST":
        loan_id = request.POST.get("loan_id")
        approved_amount = request.POST.get("approved_amount")

        loan = get_object_or_404(Loan, id=loan_id)
        loan.status = "approved"
        loan.approved_amount = approved_amount
        loan.save()

        messages.success(request, f"Loan approved for {loan.tenant_name}")
        return redirect("owner_loan_list")
    return redirect("owner_loan_list")

# ========================================
# REJECT LOAN
# ========================================
def reject_loan(request, pk):
    loan = get_object_or_404(Loan, id=pk)
    loan.status = "rejected"
    loan.save()
    messages.error(request, f"Loan rejected for {loan.tenant_name}")
    return redirect("owner_loan_list")

# ========================================
# EDIT APPROVED LOAN
# ========================================
def edit_approved_loan(request, pk):
    loan = get_object_or_404(Loan, pk=pk)
    if request.method == "POST":
        loan.approved_amount = request.POST.get("approved_amount")
        loan.save()
        messages.success(request, "Loan updated successfully!")
        return redirect("owner_loan_list")
    return render(request, "expenses/edit_approved_loan.html", {"loan": loan})

# ========================================
# DELETE APPROVED LOAN
# ========================================
def delete_approved_loan(request, pk):
    loan = get_object_or_404(Loan, pk=pk)
    if loan.status != "approved":
        messages.error(request, "Only approved loans can be deleted.")
        return redirect("owner_loan_list")
    loan.delete()
    messages.success(request, "Approved loan deleted successfully.")
    return redirect("owner_loan_list")
# expenses/views.py  (TENANT + KYC Views — Full)
from django.shortcuts import render, get_object_or_404, redirect
from django.urls import reverse
from django.contrib import messages
from django.utils import timezone
from django.contrib.auth.decorators import login_required

# import your models & forms (adjust names if you used different names)
from .models import Property, Tenant, TenantKYC
from .forms import TenantForm, TenantKYCUploadForm, TenantKYCDetailsForm

# ---------------------------------------------------------------------
# OWNER: LIST ALL TENANTS (dashboard)
# ---------------------------------------------------------------------
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from .models import OwnerTenant, Property

@login_required
def owner_tenant_list(request):
    tenants = OwnerTenant.objects.select_related('tenant_property').all().order_by('-id')

    # simple filters: ?property=ID & ?status=Pending/Active/Suspended & ?q=name
    prop_id = request.GET.get('property')
    status = request.GET.get('status')
    q = request.GET.get('q')

    if prop_id:
        tenants = tenants.filter(tenant_property__id=prop_id)
    if status:
        tenants = tenants.filter(status__iexact=status)
    if q:
        tenants = tenants.filter(name__icontains=q)

    properties = Property.objects.all()

    context = {
        'tenants': tenants,
        'properties': properties,
        'selected_property': prop_id,
        'selected_status': status,
        'query': q,
    }
    return render(request, 'expenses/owner_tenant_list.html', context)

@login_required
def add_owner_tenant(request):
    if request.method == 'POST':
        form = TenantForm(request.POST)

        if 'tenant_property' in form.fields:
            form.fields['tenant_property'].queryset = Property.objects.all()

        if form.is_valid():

            # ---- FIXED BLOCK ----
            email = form.cleaned_data.get('email')  # your form uses 'email'
            existing = OwnerTenant.objects.filter(email=email).first()
            if existing:
                messages.error(request, "A tenant with this email already exists.")
                return redirect("owner_tenant_list")
            # ----------------------

            tenant = form.save(commit=False)
            tenant.status = "pending"
            tenant.save()

            TenantKYC.objects.get_or_create(
                tenant=tenant,
                defaults={
                    "full_name": tenant.name,  # your model uses 'name'
                    "dob": None,
                    "id_type": "",
                    "id_number": "",
                    "address": "",
                    "permanent_address": "",
                    "emergency_contact": "",
                    "occupation": "",
                    "kyc_status": "pending",
                }
            )

            messages.success(request, f"Tenant '{tenant.name}' added. KYC Required.")
            return redirect("owner_tenant_list")

        else:
            messages.error(request, "Please correct the errors below.")

    else:
        form = TenantForm()
        if 'tenant_property' in form.fields:
            form.fields['tenant_property'].queryset = Property.objects.all()

    return render(request, "expenses/add_tenant.html", {"form": form})

# OWNER: EDIT TENANT
# ---------------------------------------------------------------------
@login_required
def edit_owner_tenant(request, id):
    tenant = get_object_or_404(Tenant, id=id)

    if request.method == 'POST':
        form = TenantForm(request.POST, instance=tenant)
        try:
            form.fields['property_name'].queryset = Property.objects.all()
        except Exception:
            pass

        if form.is_valid():
            form.save()
            messages.success(request, f"Tenant '{tenant.tenant_name}' updated.")
            return redirect('owner_tenant_list')
        else:
            messages.error(request, "Please correct the errors below.")
    else:
        form = TenantForm(instance=tenant)
        try:
            form.fields['property_name'].queryset = Property.objects.all()
        except Exception:
            pass

    return render(request, 'expenses/edit_tenant.html', {'form': form, 'tenant': tenant})


# ---------------------------------------------------------------------
# OWNER: DELETE TENANT
# ---------------------------------------------------------------------
@login_required
def delete_owner_tenant(request, id):
    tenant = get_object_or_404(OwnerTenant, id=id)

    if request.method == 'POST':
        tenant_name = tenant.name  # Correct field
        tenant.delete()
        messages.success(request, f"Tenant '{tenant_name}' deleted.")
        return redirect('owner_tenant_list')

    return render(request, 'expenses/delete_tenant_confirm.html', {'tenant': tenant})



# ---------------------------------------------------------------------
# OPTIONAL: Tenant KYC success page
# ---------------------------------------------------------------------
def tenant_kyc_success(request):
    return render(request, 'expenses/tenant_kyc_success.html')


from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required
from .models import OwnerTenant

# views.py
from django.shortcuts import render, get_object_or_404, redirect
from .models import OwnerTenant, TenantKYC
from .forms import TenantKYCDetailsForm, TenantKYCUploadForm

def my_kyc(request, tenant_id):
    tenant = get_object_or_404(OwnerTenant, id=tenant_id)
    
    try:
        kyc = tenant.kyc
        form = TenantKYCDetailsForm(instance=kyc)  # populate the form with existing KYC
    except TenantKYC.DoesNotExist:
        form = TenantKYCDetailsForm()  # empty form for new KYC
    
    return render(request, 'expenses/tenant_kyc.html', {
        'tenant': tenant,
        'form': form
    })

from django.shortcuts import render, redirect
from django.contrib import messages
from .models import OwnerTenant, Property
def tenant_signup(request):
    tenant_property_name = None

    if request.method == "POST":
        name = request.POST.get('name')
        phone = request.POST.get('phone')
        email = request.POST.get('email')

        tenant = OwnerTenant.objects.filter(
            name=name,
            email=email,
            phone=phone,
            is_signup_allowed=True
        ).first()

        if not tenant:
            messages.error(request, "Your details do not match the records. Contact the owner.")
            return redirect("tenant_signup")

        # Store tenant id and property in session
        request.session['tenant_id'] = tenant.id
        if tenant.tenant_property:
            request.session['property_id'] = tenant.tenant_property.id
            tenant_property_name = tenant.tenant_property.property_name

        messages.success(request, "Details verified! Proceed to KYC.")
        return redirect("tenant_kyc", tenant_id=tenant.id)

    return render(request, 'expenses/tenant/tenant_signup.html', {
        'tenant_property_name': tenant_property_name
    })


from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from types import SimpleNamespace
from .models import OwnerTenant, TenantKYC
from .forms import TenantKYCTenantForm

def tenant_kyc(request, tenant_id):
    tenant = get_object_or_404(OwnerTenant, id=tenant_id)

    try:
        kyc = tenant.kyc
        is_update = True
    except TenantKYC.DoesNotExist:
        kyc = None
        is_update = False

    if request.method == 'POST':
        form = TenantKYCTenantForm(request.POST, request.FILES, instance=kyc)
        if form.is_valid():
            kyc_obj = form.save(commit=False)
            kyc_obj.tenant = tenant
            kyc_obj.kyc_status = 'submitted'
            kyc_obj.save()
            messages.success(request, "KYC submitted successfully.")
            return redirect('tenant_kyc', tenant_id=tenant.id)
        else:
            messages.error(request, "Please correct the errors in the form.")
    else:
        form = TenantKYCTenantForm(instance=kyc)

    # Determine badge
    if kyc:
        if kyc.kyc_status == 'submitted':
            badge_text = "Submitted to Owner"
            badge_class = "bg-primary"
        elif kyc.kyc_status == 'verified':
            badge_text = "Verified"
            badge_class = "bg-success"
        elif kyc.kyc_status == 'rejected':
            badge_text = "Rejected"
            badge_class = "bg-danger"
    else:
        badge_text = "New Submission"
        badge_class = "bg-secondary"

    tenant_info = SimpleNamespace(
        full_name=tenant.name,
        phone=tenant.phone,
        email=tenant.email
    )

    return render(request, 'expenses/tenant_kyc.html', {
        'form': form,
        'tenant_info': tenant_info,
        'is_update': is_update,
        'tenant': tenant,
        'badge_text': badge_text,
        'badge_class': badge_class,
        'kyc': kyc,
    })

from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required

from .models import Tenant, TenantKYC
from .forms import TenantForm
# TENANT DETAIL (CARD VIEW)
# ---------------------------------------------------------------------
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from .models import Tenant, TenantKYC

# ---------------------------------------------------------------------
# TENANT DETAIL (CARD VIEW)
# ---------------------------------------------------------------------
@login_required
def tenant_detail(request, id):
    tenant = get_object_or_404(Tenant, id=id)
    kyc = None
    try:
        kyc = tenant.kyc
    except TenantKYC.DoesNotExist:
        kyc = None

    context = {
        'tenant': tenant,
        'kyc': kyc,
    }
    return render(request, 'expenses/tenant_detail.html', context)

# ---------------------------------------------------------------------
# OWNER: TENANT LIST (for owner dashboard)
@login_required
def owner_tenant_list(request):
    tenants = OwnerTenant.objects.all()  # Use correct model
    properties = Property.objects.all()  # For filter dropdown

    context = {
        'tenants': tenants,
        'properties': properties
    }
    return render(request, 'expenses/owner_tenant_list.html', context)

# ---------------------------------------------------------------------
# OWNER: REVIEW KYC
# ---------------------------------------------------------------------
@login_required
def owner_review_kyc(request, tenant_id):
    tenant = get_object_or_404(OwnerTenant, id=tenant_id)
    try:
        kyc = tenant.kyc
    except TenantKYC.DoesNotExist:
        messages.error(request, "KYC not submitted by this tenant yet.")
        return redirect('owner_tenant_list')

    return render(request, 'expenses/owner_review_kyc.html', {
        'tenant': tenant,
        'kyc': kyc
    })

# ---------------------------------------------------------------------
# OWNER: KYC APPROVAL LIST
# ---------------------------------------------------------------------
@login_required
def kyc_approval_list(request):
    tenants = Tenant.objects.filter(status='pending')
    context = {
        'tenants': tenants
    }
    return render(request, 'expenses/kyc_approval_list.html', context)

# ---------------------------------------------------------------------
# OWNER: APPROVE KYC
# ---------------------------------------------------------------------
@login_required
def approve_kyc(request, tenant_id):
    tenant = get_object_or_404(Tenant, id=tenant_id)
    try:
        kyc = tenant.kyc
    except TenantKYC.DoesNotExist:
        messages.error(request, "No KYC found to approve.")
        return redirect('kyc_approval_list')

    if request.method == 'POST':
        kyc.verified = True
        kyc.save()

        tenant.status = 'active'
        tenant.save()

        messages.success(request, f"KYC for '{tenant.name}' approved.")
        return redirect('kyc_approval_list')

    return render(request, 'expenses/approve_kyc_confirm.html', {'tenant': tenant, 'kyc': kyc})

# ---------------------------------------------------------------------
# OWNER: REJECT KYC
# ---------------------------------------------------------------------
@login_required
def reject_kyc(request, tenant_id):
    tenant = get_object_or_404(Tenant, id=tenant_id)
    try:
        kyc = tenant.kyc
    except TenantKYC.DoesNotExist:
        messages.error(request, "No KYC found to reject.")
        return redirect('kyc_approval_list')

    if request.method == 'POST':
        kyc.verified = False
        kyc.save()

        tenant.status = 'rejected'
        tenant.save()

        messages.success(request, f"KYC for '{tenant.name}' rejected.")
        return redirect('kyc_approval_list')

    return render(request, 'expenses/reject_kyc_confirm.html', {'tenant': tenant, 'kyc': kyc})
